使用正则表达式进行强大的模式匹配和文本检索与替换的函数

js的正则表达式以`Perl`语言的正则表达式工具为基础。

###js正则表达式的定义
匹配以s结尾的字符串（1和2等价）
    
1. RegExp对象

		var pattern = new RegExp("s$");
2. 正则表达式直接量
		
		var pattern=/s$/;
		
###正则表达式的字符类
- [...] 位于括号之内的任意字符
- [^...] 不在括号之内的任意字符
- . 除换行符和其他Unicode行终止符之外的任意字符
- \w 任何ASCII单字字符，等价于[a-zA-Z0-9_] 
- \W 任何非ASCII单字字符，等价于[^a-zA-Z0-9_] 
- \s 任何Unicode空白符
- \S 任何非Unicode空白符的字符，注意\w和\S不同
- \d 任何ASCII数字，等价于[0-9]
- \D 除了ASCII数字之外的任何字符，等价于[^0-9]
- [\b] 退格直接量

###重复
- {n,m} 匹配前一项至少n次，但是不能超过m次
- {n,} 匹配前一项n次，或更多次
- {n} 匹配前一项恰好n次
- ? 匹配前一项0次或1次
- \+ 匹配前一项1次或多次
- \* 匹配前一项0次或多次

`以上列出的重复字符可以匹配尽可能多的字符，而且允许接下来的正则表达式继续匹配。` **即“贪婪的”**

`非贪婪的重复：只需要在重复字符后加问号即可（如：??、+?、{1，5}?）`

例：   

- 字符串：“aaa”,正则表达式：/a+/,结果：aaa
- 字符串：“aaa”,正则表达式：/a+?/,结果：a

###选择、分组、引用
**正则表达式中括号()的作用：**

- 把单独的项目组合成字表达式
	- 以便可以像`处理一个独立的单元`那样用。
	- 允许在同一正则表达式的后部引用前面的字表达。
		- 通过在字符“\”后加一位或多位数字，数字制定了带括号的子表达式的在正则表达式中的位置。
		- 由于子表达式可以被嵌套在别的子表达式中，所以它的位置是被计数的左括号的位置。
		- 对正则表达式中前一子表达式的引用所指的并不是那个子表达式的模式，而是与那个模式想匹配的文本。
- 在完整的模式中定义子模式。
	- 当一个正则表达式成功地和目标字符串匹配时，可以从目标抽出和括号中的子模式匹配的部分。
	
例：匹配位于单引号或双引号之间的0个或多个字符 a"bb'cc'dd"

- /['"][^'"]*['"]/ 结果："bb'和'dd"
- /(['"])[^'"]*\1/ 结果：'cc'
- /(['"])[^\1]*\1/ 结果："bb'cc'dd"

####(?:表达式)
在JavaScript1.5中，无须创建带编码的引用就可以将正则表达式中的项目进行组合，`以"(?:"和")"来分组`。

例：

	/([Jj]ava(?:[Ss]cript)?)\sis\s(fun\w*)/

`注：子表达式(?:[Ss]cript)仅仅用于分组，这种改进了的括号并不生成引用，所以在这个正则表达式中，\2引用了与(fun\w*)匹配的文本。`

**正则表达式的选择、分组和引用字符：**

- | 选择，匹配的是该符号左边的子表达式或右边的子表达式
- (...) 组合，将几个项目组合为一个单元，这个单元可由*、+、？和|等符号使用，而且还可以记住和这个组合匹配的字符以供以后的引用使用。
- (?:...) 只组合，把项目组合到一个单元，但是不记忆与该组匹配的字符。

####(?=p) 正前向声明，要求接下来的字符都与模式p匹配，但是不包括匹配中的那些字符
**(?=表达式)**前向声明：`指定接下来的字符必须被匹配`，但并不真正进行匹配。  
 
例：
匹配一种常用的程序设计语言的名字，但只在其后有冒号时匹配。    
正则 /[Jj]ava([Ss]cript)?(?=\:)/    
字符串 javascript: The Definitive Guide    
匹配结果 javascript    

####(?!表达式) 反前向声明，要求接下来的字符不与模式p匹配
用(?!表达式)引入声明，它将是反前向声明，`指定接下来的字符都不必匹配`。

例：/Java(?!Script)([A-Z\w*])/匹配的是“Java”后跟随一个大写字母和任意多个ASCII单字字符，但是不能跟随“Script”。它与“JavaBeans”匹配，不与“Javanese”匹配。

###标记
- i 执行不区分大小写的匹配
- g 执行一个全局匹配，即找到所有匹配，而不是在找到第一个之后就停止
- m 多行模式。

###用于模式匹配的String方法
String支持四种利用正在表达式的方法：

- search
	- **参数**：正则表达式或字符串，如果是字符串将被传递给RegExp构造函数，转换成正则表达式。
	- **返回值**：匹配的开始字符位置
	- **说明**：该方法以正则表达式为参数，返回第一个与之匹配的子串的开始字符串的位置，如果没有任何匹配的子串，返回-1。search()不支持全局检索，因此它`忽略了正则表达式参数的标记g`
	- **示例**：
	
			"JavaSript".search(/script/i);
			返回：4
- replace
	- **参数**：参数一：正则表达式或字符串，参数二：替换的字符串
	- **返回值**：
	- **说明**：该方法检索调用它的字符串，根据指定的模式来匹配，如果正则表达式中设置了标志g，该方法将用替换字符串替换被检索的字符串中所有与模式匹配的子串，否则它只替换所发现的第一个与模式匹配的子串。如果第一个参数是字符串，而不是正则表达式，该方法将直接检索那个字符串。
	- **示例**：
	
			var text="5 Minutes of javascript newsletter and podcast";
			text.replace(/javascript/gi,"JavaScript");
			返回：5 Minutes of JavaScript newsletter and podcast
			
			var text="'aaa'bbb'ccc'";
        	text.replace(/'([^']*)'/g,"<$1>");
        	//返回：<aaa>bbb<ccc>
- match
	- **参数**：正则表达式
	- **返回值**：包含匹配结果的数组
	- **说明**：如果该正则表达式设置了标志g，该方法返回的数组包含的就是出现在字符串中的所有匹配；如果没有设置标志g，match()进行的就不是全局性检索，他只是检索第一个匹配，但即使match()执行的不是全局检索，它也返回一个数组。在这种情况下，数组的第一个元素就是匹配的字符串，而余下的元素则是正则表达式中用括号括起来的子表达式。index和input属性，前者包括的是在字符串中匹配开始处的字符的位置，后者则是目标字符串的一个副本。
	- **示例**：
			
			var url=/(\w+):\/\/([\w.]+)\/(\S*)/;
        	var text="Visit my blog at http://www.example.com/~david";
        	var result=text.match(url);
        	if(result!=null){
				for(var i=0;i<result.length;i++){
					console.log(i+"\t"+result[i]);
				}
			}
			//结果：
			// 0	http://www.example.com/~david"
			// 1	http
			// 2	www.example.com
			// 3	~david
- split
	- **参数**：字符串或正则表达式
	- **返回值**：数组
	- **说明**：该方法可以把调用它的字符串分解为一个子串数组，使用的`分隔符`是它的参数。
	- **示例**：
	
			"123,456,789".split(","); 
			//返回:["123","456","789"]
			
			"1 ,2, 3 ,4 ,5".split(/\s*,\s*/); 
			//返回:["1","2","3","4","5"]
	
###RegExp对象
RegExp()参数：一个或两个字符串参数，第一个参数是包含正则表达式主体的字符串，即正则表达式直接量中出现在斜线对之间的文本。第二个参数是可选的，它说明的就是该正则表达式的标记或它们的组合。
####用于模式匹配的RegExp方法
- exec()
	- **参数**：
	- **返回值**：
	- **说明**：
	- **示例**：






	





