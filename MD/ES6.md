##let和const命令

- ES5只有两种声明变量的方法：var命令、function命令。
- ES6一共有6种声明变量的方法：var命令、function命令、let命令、const命令、import命令、class命令。

###let
1. let `块级作用域`，let声明的变量只在它所在的`代码块`内有效。
- let `不存在变量提升`，它所声明的变量一定要在声明后使用，否则报错。
- let `暂时性死区`，只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
- let `不允许重复声明`，let不允许在相同作用域内，重复声明同一个变量。也不能在函数内部重新声明参数。(包括用其他方法声明的同名变量)

注意：

- for循环中的let，`for循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。`
- typeof不安全


>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

###const
const声明一个`只读的常量`。一旦声明，常量的值就不能改变。  
const的作用域与let命令相同：只在声明所在的`块级作用域`内有效。 

对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。

如果真的想将对象冻结，应该使用`Object.freeze`方法。

	const foo = Object.freeze({});
	// 常规模式时，下面一行不起作用；
	// 严格模式时，该行会报错
	foo.prop = 123;

除了将对象本身冻结，对象的属性也应该冻结。下面是一个`将对象彻底冻结的函数`。

	var constantize = (obj) => {
	  Object.freeze(obj);
	  Object.keys(obj).forEach( (key, value) => {
	    if ( typeof obj[key] === 'object' ) {
	      constantize( obj[key] );
	    }
	  });
	};

	
###块级作用域
1. 外层作用域无法读取内层作用域的变量。   
- 内层作用域可以**定义**外层作用域的同名变量。   
- 本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。   

`ES6引入了块级作用域，明确允许在块级作用域之中声明函数。块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。`

##变量的解构
ES6 允许按照一定模式，从`数组`和`对象`中提取值（严格地说，是可遍历的结构），对变量进行赋值，这被称为解构（Destructuring）。

解构在本质上，这种写法属于`“模式匹配”`。

- 完全解构：只要等号两边的模式相同，左边的变量就会被赋予对应的值。
- 不完全解构：等号左边的模式，只匹配一部分的等号右边的数组。
- 如果解构不成功，变量的值就等于undefined。

**从数组中提取值，按照对应位置，对变量赋值。**

	let [a, b, c] = [1, 2, 3];
	
等同于：
	
	let a = 1;
	let b = 2;
	let c = 3;






